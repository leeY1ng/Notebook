代理
位于客户端和服务器之间的http 实体 

缓存
http的仓库 使常用页面的副本可以保存在离客户端更近的地方

网关
连接其他应用程序的特殊web服务器

作为其他服务器的中间实体使用
通常用于将http流量转换成其他协议
网关接受请求时 好像自己是资源的源端服务器
客户端可能不知道自己正在与一个网关服务器进行通信

隧道
对http通信报文进行盲转发的特殊代理

建立起来之后 在两条连接之间对原始数据进行盲转发的http应用程序
http隧道用来在一条或多条http连接上转发非http数据 转发时不会窥探数据

常见用途：通过http连接承载加密的安全套接字层ssl流量
这样ssl流量就可以穿过只允许web流量通过的防火墙


agent代理
发起自动http请求的半智能web客户端

代表用户
发起http请求的客户端程序
所有发布web的应用程序都是http agent代理

2、url与资源

浏览因特网资源

uri 通用的资源标识符 包含两个子集 url urn

url解析

编码机制

转义表示法来表示不安全字符 %+ascii码 十六进制数

字符限制
最好把所有不安全字符进行转义 共享的规范形式

另一种极端做法 对所有字符进行转义
解析url的应用程序必须在处理url之前对其进行解码

永久统一资源定位符
在搜索资源的过程中引入另一个中间层
通过一个中间资源定位符服务器对资源的实际url进行登记
客户端可以向定位符请求一个永久url 定位符可以以一个资源作为响应
将客户端重定向到资源当前实际的url上去


3、http报文

3·1报文流

	http之间发送的数据块，这些数据块以一些文本形式的元信息开头



请求报文 ：
1、起始行 ：
	方法 请求路径 版本
2、首部 
	报文首部
3、主体
	数据块

响应报文：
1、起始行
	版本 状态码 状态短语
2、首部
	报文首部
3、主体
	响应数据块

请求方法：
get 从服务器获取文档
head 只从服务器获取文档首部
post 向服务器发送需要处理的数据
put 将请求的主体部分存储在服务器上
trace 对可能经过代理服务器传送到服务器上去的报文进行追踪
options 决定可以在服务器上执行哪些方法
delete 从服务器上删除一份文档

状态码：

100~199 信息提示

200~299 成功        
	200成功

300~399 重定向

400~499 客户端错误	
	401未授权 需要输入用户名和密码 
	404未找到 服务器无法找到所请求的资源

500~599 服务器错误



首部分类：

通用首部
	请求报文和响应报文都会出现
请求首部
	提供跟多的请求信息
响应首部
	响应信息
实体首部
	主体的长度 内容或资源自身
扩展首部
	规范中没有定义的新首部


实体的主体部分
报文的负荷 可以包括多种媒体类型

方法
get 和head 安全的方法
GET 
	客户端向服务器请求某些资源
HEAD
	在响应中只返回首部 不会返回实体的主体部分
	在不获取资源的情况下 了解资源的情况 判断类型等
	通过查看响应中的状态码 观察某个对象是否存在
	查看首部 测试资源是否被修改了

PUT
	向服务器写入文档
	让服务器用请求的主体来创建一个由所请求url命名的新文档
	如果url已经存在 就用这个主体来代替他
	put允许用户对文档进行修改

POST
	向服务器发送表单数据等

TRACE
	客户端发送请求 可能会经过防火墙 代理 网关等其他应用程序
	每个中间节点都可能修改http请求
	trace方法允许客户端在最终请求发送到客户端的时候 看它变成什么样子

	会在目的服务器发起一个环回诊断 行程最后一站的服务器会弹回一条trace响应 
	并在响应主体中携带它收到的原始请求报文
	这样客户端就可以查看在所有中间http应用程序组成请求响应链上，
	原始报文是否被修改过
	via
	trace请求不带有实体的主体部分 响应中的实体主体部分包含了响应服务器收到的请求副本

OPTIONS
	请求web服务器告知其支持的功能 可以询问服务器支持哪些方法 
	或 对特殊资源支持哪些方法

DELETE
	请求服务器删除请求url所指定的资源
	客户端无法保证一定会执行
	因为 http规范允许服务器在不通知客户端的情况下撤销请求

扩展方法
lock 锁定资源 
mkcol 创建资源
copy 复制资源
move 移动资源
如果服务器不支持这些方法 会以501 无法实现状态码响应

状态码

100~199 信息状态码
	100 收到请求的初始部分 请客户端继续
	101 服务器正在根据客户端的指定 将协议切换成update首部所列的协议
	
200~299 成功状态码
	200 OK
	201 创建服务器对象的请求 
		响应的实体主体部分包含各种引用了已创建的资源的url
		location首部包含的是最具体的引用
	202 请求已被接受
	203 实体首部包含的信息不是来自源端服务器 来自资源的副本
	204 响应报文中包含若干首部和一个状态行 但没有实体的主体部分
		用于在浏览器不转为显示新文档的情况下 对其更新
	205 用于浏览器的代码 负责告知浏览器清楚当前页面中所有html表单元素
	206 成功执行了部分或range请求 
		必须包含content-range date btag content-location首部 

300~399 重定向状态码
	替代位置来访问行文或提供一个替代的响应而不是资源的内容
	如果资源被移动 可以发送一个重定向状态码和可选的location首部
	来告知客户端资源已被移走 以及现在可以在哪里看到

	通过某些重定向状态码对资源的应用程序本地副本与源端服务器上的资源进行验证
	查看资源是否是最新的 或者在源端服务器上是否被修改过

	300 客户端请求一个实际指向多个资源的url时会返回这个状态码 
	301 请求的url已被移除时使用，响应location首部中应该包含资源现在所处的url
	302 与301类似 客户端应该使用location首部给出的url来临时定位资源 将来的请求仍然使用老url
	303 see other 告知客户端应该用另一个url来获取资源 新url位于响应报文location首部
		允许post请求的响应将客户端定向到某个资源上去
	304 not modified 客户端可以通过所包含的请求首部 使其请求变成有条件的
		如果客户端发起了一个条件get请求 而最近资源未被修改的话 就用这个状态码来说明资源未被修改
		带有这个状态码的响应不应该包含实体的主体部分
	305 use proxy 用来说明必须通过一个代理来访问资源 
		代理的位置由location首部给出
		重要的一点是：客户端是相对某个特定的资源来解析这条响应
		不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行
		如果客户端错误的让代理介入了某条请求，可能会引发破坏行为 造成安全漏洞

	307 temporary redirect 与301类似 但客户端英爱使用location首部给出的url来临时定位资源 将来的请求使用老url

400~499 客户端错误状态码
	客户端可能会发送一些服务器无法处理的数据

	400 bad request 告知客户端发送了错误的请求
	401 unauthorized 与适当的首部一起返回 这些首部中请求客户端在获取对资源的访问权之前 对自己进行认证
	402 payment required //
	403 forbidden 说明请求被服务器拒绝了 
		如果服务器想说明为什么拒绝请求 可以包含实体的主体部分对原因进行说明
		但常在服务器不想说明原因的状态下使用
	404 not found 服务器无法找到所请求url 	
	405 method not allowed 发送请求带有服务器不支持的方法时 使用此
		响应中包含allow首部 告知客户端对请求url使用哪些方法
	406 not acceptable 客户端可以指定参数来说明它们愿意接收什么类型的实体
		服务器没有与客户端可以接受的url相匹配时 使用此 
		服务器会包含一些首部以便客户端弄清楚为什么请求无法满足
	407 proxy anthentication required 与401类似 要求对资源进行认证的服务器
	408 request timeout 如果客户端完成请所花的时间太长，服务器可以回送此状态码并关闭连接
	409 conflict 请求在资源上引发冲突 服务器担心请求会引发冲突 可以发送此状态吗
	410 gone 与404类似
	411 length required 服务器要求请求报文包含content-length  首部时使用
	412 precondition failed 客户端发起条件请求 且其中一个条件失败了的时候使用
		客户端包含了expect首部时发起的请求就是条件请求
	413 request entity too large 请求实体太大
	414 request uri too long 请求uri太长
	415 unsupported media type 服务器无法理解或无法支持客户端所发实体的内容类型时
	416 requested range not satisfiable 请求报文所请求的是指定资源的某个范围 而此范围无效或无法满足
	417 expectation failed 请求的expect请求首部包含了一个期望 但服务器无法满足此期望时

500~599 服务器错误状态码
	500 internal server error 发武器遇到妨碍它为请求提供服务的错误
	501 not implemented 客户端发起的请求超过服务器的能力范围
	502 bad gateway 作为代理或网关使用的服务器从请求响应链的下一条响应链路上收到一条伪响应
		比如 无法连接其父网关时
	503 service unavailable 服务器现在无法为请求提供服务 但将来可以
		在响应中包含retry After首部 告诉服务器什么时候可用资源
	504 gateway timeout 与408类似 响应来自一个网关或代理 等待另一服务器对其请求进行响应超时了
	505 http version not supported 服务器收到的请求使用了它无法或不愿支持的协议版本


首部 
和方法共同决定了客户端和服务器能做什么事情

通用首部 
客户端和服务器都可以使用的首部

connection 		  
允许客户端和服务器指定与请求、响应连接有关选项

date 			  提供日期和时间标志 说明报文是什么时间创建的

mime-version 	  给出了发送端使用的mime版本
trailer 		  报文采用了分块传输编码方式 可以用这个首部
				  列出报文拖鞋部分的首部集合
transfer-encoding 告知接收端为了保证报文的可靠传输 对报文采用什么编码方式
upgrade 		  给出了发送端可能想要升级使用的新版本或协议
via 			  显示了报文经过的中间节点（代理 网关）

通过缓存首部
cache-control     随报文传送缓存指示
//pargma 			  另一种随报文传送指示的方式 但不专用于缓存

请求首部：
请求报文特有 譬如 expect

client-ip		 提供运行客户端机器的ip地址
from 			 提供客户端用户的email地址
host             给出了接收请求的服务器主机号和端口号
referrer 		 提供了包含当前请求uri的文档的url
ua-color 		 提供了与客户端显示器显示颜色
ua-cpu  		 cpu类型或制造商
ua-disp          显示器能力
ua-os 			 客户端机器操作系统
ua-pixels        客户端显示器像素信息
user-agent 		 将发起请求的应用程序名称告知服务器

accept首部  为客户端提供了一种将其喜好和能力告知服务器的方式

accept-charset   发送哪些媒体类型
accpet-encoding  发送哪些字符集
accept-language  发送哪些语言
TE 				 可以使用哪些扩展传输编码

条件请求首部

expect     		    允许客户端列出某请求O所要求的服务器行为
if-match		    实体标记与文档当前的实体标记相匹配 就获取这份文档
if-modified-since   除非在某个指定日期之后资源被修改过 否则就限制这个请求
if-none-match		实体标记语当前文档实体标记不符 就获取这份文档
if-range			允许对文档的某个范围进行条件请求
if-unmodified-since	除非在某个指定日期之后资源没有被修改过 否则就限制这个请求
range  				如果服务器支持范围请求，就请求资源的指定范围

安全请求首部

authorization 		包含客户端提供给服务器 一边对其自身进行认证的数据
cookie 				客户端用它向服务器传送一个令牌 隐含了安全功能
cookie2				说明请求端支持的cookie版本

代理请求首部

max-forward   		通往源端服务器路径上，将请求转发给其他代理或网关的最大次数
					与trace方法一起使用
proxy-authorization 与authorization相同
proxy-connection 	与connection相同

响应首部：
响应报文有自己的首部集，以便为客户端提供信息 
例如server 服务器类型 版本


age 				响应持续时间
public 				服务器为其资源支持的请求方法列表
retry-after			如果资源不可用 在此日期或时间重试
server 				服务器应用程序软件名称或版本
title 				html文档的标题
warning				比原因短语更详细的警告报文

协商首部
accept-ranges 		对此资源来说 服务器可接受的范围类型
vary 				服务器查看的其他首部的列表 可能会使响应发生变化
					首部列表 服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端

安全响应首部
proxy-authenticate	来自代理对客户端的质询列表
set-cookie 			可以在客户端设置一个令牌 以便服务器对客户端进行标识
set-cookie2 		与set-cookie类似
www-authenticate	来自服务器对客户端的质询列表


实体首部 ：
应对实体主体部分的首部
例如 说明实体的主体的数据类型

allow 				列出了可以对此实体执行的请求方法
location 			告知客户端实体实际上位于何处 用于将接收端定向到资源的位置上

内容首部
content-base 		解析主体相对url的基础url
content-encoding 	对主体执行的任意编码方式
content-language 	理解主体时最适宜使用的自然语言
content-length 		主体的长度或尺寸
content-location 	资源实际所处的位置
content-md5 		主体的md5校验和
content-range       整个资源中此实体表示的字节范围
content-type 		主体的对象类型

实体缓存首部

ETag 				与此实体相关的实体标记（某个特定资源版本的标识符）
Expires 			实体不在有效 要从原始的源端再次获取此实体的日期和时间
Last-modified 		这个实体最后一次修改的日期和时间


扩展首部：
非标准首部



4、连接管理

http是如何使用tcp连接的
tcp连接的时延 瓶颈以及存在的障碍
http的优化 包括并行连接 keep-alive持久连接 管道化连接
管理连接时应该不应该做的事

TCP连接
tcp/ip 分组交换网络分层协议集

浏览器解析出主机名
通过dns查询主机名的ip地址
浏览器获得端口号
浏览器发起到ip地址端口号的连接
浏览器向服务器发送一条http get的报文
浏览器从服务器读取http响应报文
浏览器关闭连接


tcp可靠数据管道
http连接实际上是tcp连接和一些使用连接的规则
tcp为http提供了一条可靠的比特传输管道
从tcp连接一端填入的字节会从另一端以原有的顺序 正确的传送过来

TCP流是分段的 由IP分组传送
TCP数据通过IP分组或IP数据报的小数据块发送

http是协议栈的最顶层 
https就是在http和tcp之间插入了一个TLS/SSL 密码加密层

HTTP      应用层
  |
(TLS/SSL) 安全层
  |
TCP       传输层
  |
 IP       网络层
  |
网络接口  数据链路层



http要传送一条报文时 
会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输
TCP收到数据流之后 会将数据流看成被称做段的小数据块
并将块封装在IP分组中 通过因特网传输 
所有这些由TCP/IP软件来处理 


每个TCP段由IP分组承载 从一个ip地址发送到另一个ip地址

每个ip分组包括：
一个ip分组首部：源和目的ip地址 长度 其他标记
一个tcp段首部： tcp端口号 tcp控制标记 以及 数据排序和完整性检查的数字值
一个tcp数据块

保持TCP连接的正确运行

任何时间计算机都可以有几条tcp连接处于打开状态 
tcp是通过端口号保持这些连接正确运行

tcp连接通过4个值来识别：
源ip地址	源端口号	目的ip地址	目的端口号
这4个值唯一的定义了一条连接 两个不同的tcp连接不能拥有4个完全相同的地址组件值
不同连接的部分组件可以用拥有相同的值

有些连接共享了相同的目的端口号 有些使用了相同的源ip地址等


用TCP套接字编程

tcp编程接口 套接字api提供主要接口

套接字api允许用户创建tcp的端点数据结构 
将这些端点与远程服务器的tcp端点进行连接 并对数据流进行读写
tcp api隐藏了所有底层网络协议的握手细节 
以及tcp数据流与ip分组之间的分段和重装细节

客户端						服务器	

						s1 创建新的套接字 socket
						s2 将套接字绑定到端口80上去 bind
						s3 允许套接字进行连接  listen
						s4 等待连接 accept

c1获取ip地址 端口号
c2创建新的套接字
c3连接到服务器ip:port上去
		
						s5 通知应用程序有连接到来
c4连接成功				s6 开始读取请求
c5发送http请求
c6等待http响应
						s7 处理http请求报文
						s8 回送http响应
c7处理http响应			s9 关闭连接
c8关闭连接

tcp客户端和服务器与通过TCP套接字接口进行通信

从s4开始 客户端根据url判定出ip地址和端口号
并建立一条到服务器的tcp连接
建立连接花费一些时间 	取决于服务器距离 负载 网络拥堵

一旦建立连接 客户端发送http请求 服务器读取请求 
服务器获取请求报文 对请求进行处理 执行请求动作
并将数据写会客户端 客户端读取数据 并对响应数据进行处理



对TCP性能的考虑

http位于tcp上层 
http事务的性能取决于底层tcp通道的性能
理解tcp连接性能特点 更好的理解http连接优化特性


http事务的时延


dns查询 -连接-请求-处理-响应-关闭

与传输请求和响应报文相比  事务处理时间很短 除非客户端服务器超载 或处理复杂动态资源

http事务时延以下几种原因：

1、客户端需要根据uri确定web服务器的ip地址 端口号
	如果最近没有对uri的主机名进行访问 
	通过dns解析系统将uri的主机名转换成一个ip地址要花费数十秒
	（大多数http客户端都有小的dns缓存 用来保存近期访问站点的ip地址
		如果已经缓存 查询立即完成）

2、接下来 客户端向服务器发送一条tcp连接请求 等待服务器回送一个请求接受应答
	每条tcp连接都会有连接建立时延 这个值最多一两秒 
	如果有数百个http事务 这个值会快速叠加上去

3、一旦连接建立起来 客户端会通过新建立的tcp管道来发送http请求
	数据到达时 web服务器会从tcp连接中读取请求报文 并对请求进行处理

4、web服务器回送http响应 这也花费时间

tcp网络时延大小取决于硬件速度 网络和服务器负载  请求响应报文尺寸 客户端服务器距离
tcp技术的复杂性也会产生影响


性能聚焦区域

常见tcp相关时延
包括：

tcp连接建立握手
tcp慢启动拥塞控制
数据聚集的nagle算法
用于捎带确认的tcp延迟确认算法
time_wait时延和端口耗尽



tcp连接的握手时延


建立一条新的tcp连接时，甚至在发送任意数据之前 
tcp软件之间会交换一系列IP分组 对连接的有关参数进行沟通
如果连接只用来传送少量数据 这些交换过程就会严重降低http性能

TCP连接握手需要经过以下几个步骤：

1、请求新tcp连接时，客户端需要向服务器发送一个小的TCP分组
	这个分组中设置了特殊的SYN标记 说明这是一个连接请求

2、如果服务器接受连接  就会对一些连接参数进行计算 
	并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位
	说明连接请求已被接受

3、最后 客户端向服务器回送一条确认信息，通知它连接已成功建立
	现代的TCP栈允许客户端在这个确认分组中发送数据
	
http程序员不会看到这些分组（由tcp/ip软件管理）
看到的只是创建tcp连接时存在的时延

通常http事务不会交换太多数据 此时 SYN/SYN+ACK 握手会产生可测量的时延

TCP连接的ACK分组通常都足够大 可以承载整个http请求报文
很多http服务器响应报文可以放入一个ip分组中去

最后结果是 小的http事务在tcp建立上花费50%或更多
			（重用现存连接 减小tcp建立时延造成的影响）



4·4·2延迟确认




因特网无法确保可靠的分组传输 （路由器负载的话 可以随意丢弃分组）
tcp实现了自己的确认机制来确认数据的成功传输

每个tcp段都有一个序列号和数据完整性的校验和
每个段的接收者收到完好的段时会向发送者回送小的确认分组 
如果发送者没有在指定的窗口时间内收到确认信息 发送者就认为分组已经被破坏
需重发数据

由于确认报文很小 TCP允许在发往相同方向的输出数据分组中对其进行捎带
TCP将返回的确认信息与数据分组结合在一起 更有效的利用网络
为了增加确认报文找到同向传输数据分组的可能性 
很多TCP栈实现了 延迟确认 算法
延迟确认算法在一个特定的窗口时间（100~200ms）内将输出确认存放在缓冲区中
以寻找能够捎带它的输出数据分组
如果在这个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送


但 http具有双峰特征的请求-应答行为降低了捎带信息的可能
当希望有相反方向回传分组的时候，偏偏没有那么多
通常 延迟确认算法 会引入相当大的时延 
根据使用的操作系统不同 可以调整或禁止延迟确认算法

对tcp栈的任何参数进行修改之前，要对自己目前的行为有清醒的认识
TCP中这些算法目的防止设计欠佳的应用程序对因特网造成破坏
对TCP配置进行任意的修改 
都要绝对确认应用程序不会引发这些算法所要避免的问题


TCP慢启动

tcp数据传输性能还取决于tcp连接的使用期 
tcp连接会随着时间进行自我调谐
起初会限制连接的最大速度，如果数据成功传输 会随着时间的推移提高传输速度
这种调谐成为慢启动 防止因特网的突然过载或拥塞


tcp慢启动限制了一个tcp端点在任意时刻可以传输的分组数
每成功接收一个分组 发送端就有了发送另外两个分组的权限
如果某个http需要大量数据发送，是不能一次将所有分组都发送出去
必须发送一个分组 等待确认 然后可以发送两个分组 每个分组都必须被确认
这样就可以发送给四个分组 以此类推 
这种方式称为打开拥塞窗口

由于存在这种拥塞控制特性 所以新连接的传输速度会比已经交换过一定量数据的、
已调谐的连接慢一些 由于已调谐连接更快 
所以http中有一些可以重用现存连接的工具 （http持久连接）


negla算法与tcp_nodelay

tcp有一个数据流接口 
应用程序可以通过它将任意尺寸的数据放入tcp栈中
--即使只放一个字节也可以  “发送端傻窗口综合症”

但每个tcp段中至少装载了40字节的标记和首部  
如果tcp发送了大量包含少量数据的分组 网络性能严重下降

nagle算法试图发送一个分组之前 将大量tcp数据绑定在一起
 以提高网络效率

nagle鼓励发送全尺寸的段 lan上最大尺寸分组1500字节 因特网上几百字节
只有当其他分组都被确认后，nagle算法才允许发送非全尺寸的分组
如果其他分组仍然在传输过程中，就将那部分数据缓存起来
只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，
才会将缓存的数据发送出去 
（变体：对超时和确认逻辑的修改 基本算法会使数据的缓存比一个TCP段小一些）

nagle算法会引发几种性能问题：
首先 小的http报文可能无法填满一个分组 
	会因为等待永远不会到来的额外数据产生延时
其次 nagle算法与延迟确认之间存在交互问题 
	nagle阻止数据的发送 直到有确认分组抵达为止
	但确认分组自身会被延迟算法延迟100~200ms

http应用程序通常在自己的栈中设置参数TCP_NODELAY 禁用nagle算法
提高性能 如果要这么做，一定确认会向tcp写入大块数据，这样不会产生小的分组


TIME_WAIT累积与端口耗尽

很严重的性能问题 会影响到性能基准 现实中较少出现

当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块 
用来记录最近所关闭连接的ip地址和端口号
这类信息会维持一小段时间 通常是所估计的最大分段的使用期两倍 2分钟左右
以确保在这段时间内不会创建具有相同地址和端口号的新连接
实际上这个算法可以防止在两分钟内创建 
关闭并重新创建两个具有相同ip地址和端口号的连接


现在高速路由器的使用 使得重复分组几乎不可能在连接关闭的几分钟之后
出现在服务器上 有些操作系统会将2msl设置较小的值 但超过此值要小心，
分组确认会被复制
如果来自之前的连接的复制分组插入了具有相同连接值的新TCP流  会破坏TCP数据

2msl的连接关闭延迟通常不是什么问题 但在性能基准环境下就可能会成为一个问题

进行性能基准测试时，通过只有一台或几台用来产生流量的计算机连接到某系统中去
这样就限制了连接到服务器客户端的ip地址数
而且 服务器通常会在http默认的tcp80端口上进行监听
用time_wait防止端口号重用 这些情况也限制了可用的连接值组合

在只有一个客户端和一台web服务器的异常情况下，构建一条tcp链接4个值
源ip 源端口 目的ip 目的端口
其中3个都是固定 只有源端口可以随意改变
客户端每次连接到服务器上去时，都会获得一个新的源端口
 实现连接的唯一性
由于可以用源端口数量有限 且在2msl内连接无法重用
连接被限制在 60000/120 = 500次/秒
如果不断进行优化 并且连接率不高于500 可确保不会遇到time_wait端口耗尽问题
要修正这个问题  可以增加客户端负载生成机器的数量 
或者确保客户端和服务器在循环使用几个虚拟ip地址以增加更多连接组合

即便没有遇到端口耗尽问题 要特别小心有大量连接处于打开的情况，
或处于等待状态的链接分配了大量控制块的情况
在有大量打开连接或控制块的情况下 ，有些操作系统速度严重减缓


HTTP连接的处理

操作和优化连接的http技术

常被误解的connection首部

http允许在客户端和最终服务器之间存在一串http中间实体（代理 高速缓存）
可以从客户端开始 逐跳的将http报文经过这些中间设备 
转发到源端服务器上去（或者进行反向传输）

在某些情况下，
两个相邻的http应用程序会为它们共享的连接应用一组选项
http的connection首部字段中有一个由逗号分隔的 连接标签 列表 
这些标签为此连接 指定了一些不会传播到其他连接中去的选项
可以用connection close来说明发送下一条报文之后必须关闭的连接

connection首部可以承载3种不同类型的标签 有时候很费解：

http首部字段名 		列出了只与此连接有关的首部
任意标签值 			用于描述此连接的非标准选项
值close 			说明操作完成之后需关闭这条持久连接


如果标签中包含了一个http首部字段名称 
那么这个首部字段就包含了与一些连接有关的信息
不能将其转发出去 在将报文转发出去之前 
必须删除connection首部列出的所有首部字段

由于connection首部可以防止无意中对本地首部的转发 
因此将逐跳首部名放入connection首部 被称为对首部的保护


http程序收到一条带有connection请求的报文时
接收端会解析发送端请求的所有选项 并将其应用 
然后会在将此报文转发给下一条地址之前
删除connection首部以及connection首部中列出的所有首部


可能还会有少量没有作为connection首部值列出 
但一定不能被代理转发的逐跳首部
其中包括
proxy-authenticate
proxy-connection 
transfer-encoding
upgrade


4·3·2 串行事务处理延时

如果只对连接进行简单的管理 TCP的性能时延可能会叠加起来
假设
一个包含了3个嵌入图片的web页面
浏览器需要发起4个http事务才显示此页面
1个用于顶层html页面
3个用于嵌入的图片
如果每个事务都需要（串行的建立）一条新的连接
那么连接延时和慢启动就会叠加起来


除了串行加载引入的实际时延之外 加载一幅图片时
页面上其他地方都没有动静也会让人觉得速度很慢 
(同时加载多幅图片比一次加载一幅图片要慢)
用户更希望同时加载多幅图片

串行加载的另一个缺点是：
有些浏览器在对象加载完毕之前无法获知对象的尺寸
而且它们可能需要尺寸信息来决定将对象放在屏幕什么位置上
所以在加载足够多的对象之前 无法在屏幕上显示任何内容
在这种情况下 浏览器串行装载对象的进度很正常
但用户的却是一个空白的屏幕 对装载进度一无所知
（html设计者可以在图片等嵌入式对象html标签中
显式的添加宽高属性，消除布局时延 显式的提供嵌入图片的宽高 
浏览器可以从服务器收到对象之前确定图形的布局）

提高http连接性能：

并行连接：
通过多条TCP连接发起并发的http请求

持久连接：
重用TCP连接，以消除连接及关闭时延

管道化连接：
通过共享的TCP连接发起并发的http请求

复用的连接
交替传送请求和响应报文


并行连接：
http允许客户端打开多条连接，并行的执行多个http事务
每个事务都由自己的TCP连接

并行连接可能会提高页面的加载速度：

包含嵌入对象的组合页面如果能（通过并行链接）
克服单条连接的空载时间和带宽限制
加载速度也会提高、时延可以重叠起来 
如果单条连接没有充分利用客户端的因特网带宽
可以将未用带宽分配来装载其他对象

首先装载封闭的html页面 然后并处理其余3个事务
每个事务都有自己的连接 图片装载并行 连接时延也是重叠的


并行连接不一定更快

并行连接速度可能会更快但不一定总是更快
客户端的网络带宽不足时 大部分时间是用来传输数据的
在这种情况下，
一个连接到速度较快服务器上的http事务会很容易耗尽所有可用的带宽
如果并行加载多个对象，每个对象都会去竞争这有限的带宽
每个对象都会以较慢的速度按比例加载 
这种带来的性能提升很小 甚至没有提升

打开大量连接会消耗很多内存资源 引发自身性能问题
复杂的web页面可能会有数十或数百个内嵌对象
客户端可能可以打开数百个连接

但web服务器通常要同时处理很多其他用户的请求
所以很少web服务器希望出现这样的情况
100个用户同时发出申请，每个用户打开100个连接  
服务器要处理10000个连接 会造成服务器性能严重下降 对高负荷代理亦如此

实际上 浏览器确实使用了并行连接 
但它们会将并行连接的总数限制为一个较小的值（通常是4个）
服务器可以随意关闭来自特定客户端的超量连接


并行连接可能让人“感觉”更快一些

多个组件对象同时出现在屏幕 在感觉上可能更快一点
用户可以看到加载的进展
（渐进式图片会先显示低分辨率的近似图形
然后再逐渐增加图片的分辨率
而随着渐进式图片应用的逐步增加 效果更明显）


持久连接

web客户端经常打开同一个站点的连接

一个web页面上大部分内嵌图片通常来自同一个web站点
而一部分指向其他对象的超链接通常都指向同一个站点

因此
初始化了对某服务器http请求的应用程序很可能在不久的将来
对那台服务器发起更多的请求
这被称为站点本地性

因此
http1.1允许http设备在事务处理结束之后将tcp连接保持在打开状态
 以便为未来的http请求重用现存连接 
 在事务结束之后仍然保持在打开状态的tcp连接成为持久连接

 非持久连接会在每个事务结束之后关闭 持久连接会在不同事务之间保持在打开状态 直到客户端或服务器决定将其关闭为止

 重用已对目标服务器打开的空闲持久连接 
 就可以避开缓慢的连接建立阶段
 而且已经打开的连接也可以避免 慢启动的拥塞适应阶段 更快的进行数据传输

 持久以及并行连接 

 并行连接缺点：
 每个事务都会打开一条新连接 耗费时间和带宽
 tcp慢启动 每条新连接性能也会降低
 可打开并行连接数量有限


 持久连接降低了时延和连接建立的开销 将连接保持在已调谐的状态
 减少了打开连接的潜在数量 

 管理持久连接要小心累积大量空闲连接 耗费本地以及远程客户端和服务器的资源

 持久连接和并行连接配合使用是最高效的方式

现在很多web应用程序都会打开少量并行连接 每一个都是持久连接
持久连接两种类型：
老 keep-alive连接 
现 persistent连接


keep-alive：
一条持久连接实现事务的传输
通过connection：keep-alive 首部将一条连接保持在打开的状态


如果服务器愿意为下一条请求将连接保持在打开状态
就在响应中包含相同的首部
如果没有此首部 客户端就认为服务器不支持keep-alive 发回响应报文立即关闭

kee-alive只是将连接保持在活跃状态 
发出kee-alive请求之后，客户端和服务器不一定会同意进行keep-alive对话
它们可以在任意时间关闭空闲的keep-alive连接 并可随意限制keep-alive连接所处理事务的数量

keep-alive行为：

timeout 响应首部发送 估计了服务器希望将连接保持在活跃状态的时间
		不是承诺值
max     响应首部发送 估计了服务器还希望为多少个事务保持此连接的活跃状态 
不是承诺值

还支持任意未经处理的属性 用于诊断和调试语法为name [=value]

keep-alive首部可选 只有在提供connection keep-alive才会使用它
例子：
Connection: keep-alive;
keep-alive:max=5,timeout=120 
服务器最多还会为另外5个事务保持连接的打开状态 
或将打开状态保持到连接空闲了2分钟之后

keep-alive连接的限制和规则

不是默认使用 必须发送一个connection keep-alive首部才能激活keep-alive连接

connection keep-alive 首部必须随所有希望能保持持有连接的报文一起发送
如果客户端没有发送 服务器就会在那条连接请求结束后关闭

客户端探明响应中没有此首部 就可以知道服务器发出响应之后就关闭连接了

在无需检测到连接的关闭即可确定报文实体主体的部分长度的情况下，
才能将连接保持在打开状态
也就是说实体主体部分必须有content-length 
有多部件媒体类型
或用分块传输编码的方式进行了编码
这样 事务处理的另一端就无法精确检测一条报文的结束和另一条报文的开始

代理和网关必须执行connection首部的规则 必须在讲报文转发出去或将其高速缓存之前 删除在connection首部中命名的所有首部字段和首部自身

不应该与无法确定是否支持从connection首部的代理服务器建立keep-alive连接 防止出现哑代理问题 


技术上讲 应该忽略所有来自http1.0设备的connection首部字段
(包含connection keep-alive) 它们可能由较老的代理服务器误转发
尽管有在老代理商挂起的危险，有些客户端和服务器还是会违反这条规则

除非重复发送请求会产生其他副作用 否则如果在客户端收到完整的响应之前连接就关闭了 
客户端要做好重试请求的准备


keep-alive和哑代理

web客户端的connection:keep-alive首部应该只对这条离开客户端的tcp链路产生影响
如果客户端正与一台web服务器对话 客户端可以发送一个此首部告知服务器希望保持连接 如果服务器支持 就回送一个相应的首部 否则就不会送


connection和盲中继

问题出在代理上-尤其是不理解connection首部 而且不知道在沿着转发链路将其发送出去之前 
应该将该首部删除的代理 
很多老或简单的代理都是盲中继
它们只是将字节从一个连接转发到另一个连接中去
不对connection首部进行特殊处理

（服务器认为对方请求保持连接活跃 处理连接后不会关闭
代理会忽略连接上所有新的请求，等待连接关闭
由于代理不会对其进行处理 所以客户端在keep-alive连接上发送的第二条请求会被挂起）

1、客户端向代理发送了一条报文 
其中包含了connection：keep-alive首部
如果可能的话 请求建立一条keep-alive连接
客户端等待响应 以确定对方是否认可它对keep-alive信道的请求

2哑代理收到了这条http请求 但他并不理解connection首部
代理也不知道keep-alive是什么意思 只是沿着转发链路
将报文一字不差的发给服务器 
但connection首部是个逐跳首部 
只适用于单条传输链路 不应该沿着传输链路向下传输

（逐跳首部：
分在此类别中的首部只对单次转发有效
会通过缓存或代理而不再转发
若需要使用hop-by-hop首部
需提供connection首部字段）


3经过中继的http请求到达服务器 
当web服务器收到经代理转发的connectionkeep-alive首部时
误以为（这个代理看起跟客户端一样）希望进行keep-alive对话
服务器同意进行keep-alive对话 
此时web服务器认为它在与代理进行keep-alive对话 会遵循keepalive的规则 但代理却一无所知

4哑代理将服务器的响应报文发回客户端 并将来自服务器的connection首部一起发送过去
客户端看到这个首部认为代理同意keep-alive对话
此时客户端和服务器都认为他们在进行keep-alive对话 
但代理却一无所知


5代理对keep-alive一无所知 然后等待源服务器关闭连接
但源服务器认为代理已经显式的请求它将连接保持在打开状态了
不会关闭连接 代理就会挂在那里等待连接关闭

6客户端收到了回送的响应报文 立即转发下一条请求 
在keep-alive连接上向代理发送另一条请求 
而代理并不认为同一条连接上会有其他请求到来 请求被忽略
浏览器就在这里转圈 不进行任何进展

7这种错误通信方式将浏览器处于挂起状态 直到客户但或服务器将连接超时 关闭



代理和逐跳首部

为避免此类问题的发生 
现代代理绝不能转发connection首部和所有名字出现在connection的首部
如果一个代理收到connection首部 不应该转发connection首部
或者所有名微keep-alive首部


包括其他未在connection内列出的首部 
proxy-authenticate
proxy-connection
transfer--encoding
upgrade
也不能转发


插入proxy-connection

对盲中继变通做法 并不要求所有http都是高版本
引入了proxy-connection新首部
 
 问题是哑代理盲目转发connection：keep-alive之类的逐跳首部惹出了麻烦

逐跳首部只与一条特定的连接有关 不能被转发 当下游服务器误将转发来的首部作为代理自身的请求解释
用它来控制连接 就出现了问题 

网景做法：浏览器向代理发送非标准的proxy-connection扩展首部
不是官方支持的connection首部

如果代理是盲中继 服务器会忽略此首部 不会带来任何问题
如果代理是聪明的代理（能够理解持久连接的握手动作
就用一个connection首部取代无意义的proxy-connection首部
将其发送到服务器 以达预期效果）

客户端和服务器之间只有一个代理时可以这么做

如果包含哑代理和聪明代理 问题又一次出现
多层次代理 仍然无法解决

网络中不可见代理很常见 可以是防火墙 拦截缓存
或反向代理服务器的加速器 
这些设备对浏览器不可见
浏览器不会向他们发送proxy-connection首部
透明的web应用程序正确的实现持久连接很重要


http1.1 持久连接 
perisitent取代了keep-alive
目的与keep-alive连接目的相同 但工作机制更优

1.1持久连接在默认情况下是激活状态
除非特别指明 所有1.1连接都是持久的 
要在事务处理结束之后将其关闭 
1.1应用程序必须向报文中显式的添加connection：close首部
以前的版本keep-alive要不可选要不不支持

1.1客户端在收到响应后 除非响应中包含了connection：close首部
不然连接就保持在打开状态

客户端和服务器仍然可以随时关闭空闲的连接 不发送connection：close 并不意味服务器承诺永远将连接维持在打开状态


持久连接的限制和规则




